--1.Create AFTER UPDATE trigger to track product price changes

CREATE TABLE PRODUCT_PRICE_AUDIT (
	AUDIT_ID SERIAL PRIMARY KEY,
	PRODUCT_ID INT, 
	PRODUCT_NAME VARCHAR (40),
	OLD_PRICE DECIMAL (10,2),
	NEW_PRICE DECIMAL (10,2),
	CHANGE_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	USER_NAME VARCHAR (50) DEFAULT CURRENT_USER
)

--Define the Trigger Function

CREATE OR REPLACE FUNCTION AFTER_UPDATE_PRODUCT() RETURNS TRIGGER AS $$
BEGIN
INSERT INTO product_price_audit (
	 product_id,
     product_name,
     old_price,
     new_price
) VALUES (
	OLD.product_id,
    OLD.product_name,
    OLD.unit_price,
    NEW.unit_price
);
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL

--Create the Trigger

CREATE TRIGGER AFTER_UPDATE_TRIGGER AFTER
UPDATE ON PRODUCTS
FOR EACH ROW EXECUTE FUNCTION AFTER_UPDATE_PRODUCT()

--Test the trigger

UPDATE PRODUCTS
SET UNIT_PRICE = UNIT_PRICE * 1.10
WHERE PRODUCT_ID = 58

SELECT *
FROM PRODUCT_PRICE_AUDIT

--2.Create stored procedure using IN and INOUT parameters to assign tasks to employees

CREATE TABLE IF NOT EXISTS EMPLOYEE_TASKS (
	TASK_ID SERIAL PRIMARY KEY,
	EMPLOYEE_ID INT, 
	TASK_NAME VARCHAR(50),
	ASSIGNED_DATE DATE DEFAULT CURRENT_DATE
);

--Create the Stored Procedure

CREATE OR REPLACE PROCEDURE ASSIGN_TASK (
	IN P_EMPLOYEE_ID INT, 
	IN P_TASK_NAME VARCHAR(50),
	INOUT P_TASK_COUNT INT DEFAULT 0
)
LANGUAGE PLPGSQL AS $$
BEGIN
INSERT INTO EMPLOYEE_TASKS (
	EMPLOYEE_ID, TASK_NAME
) VALUES (
	p_employee_id, p_task_name
);
SELECT COUNT (*)
INTO p_task_count
FROM EMPLOYEE_TASKS
WHERE EMPLOYEE_ID = p_employee_id;
RAISE NOTICE 'Task "%" assigned to employee %. Total tasks: %',
        p_task_name, p_employee_id, p_task_count;
END;
$$

CALL ASSIGN_TASK(
	1,'Review Reports'
);

